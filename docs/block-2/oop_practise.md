---
sidebar_position: 11
---
# Практика
Після того, як ми обговорили теорію ООП, перейдім безпосередньо до
Котліну.

Уявімо, що нам потрібно зберегти чи структурувати наші дані про наших
улюблених котів чи кішок.
Нагадаю, що там у нашого кота є:
![Кіт](images/oop_cat_ua.excalidraw.svg#invert)
Для опису використаємо `object`, про який зараз поговоримо.

### Object
Одним із видів об'єктів у котлині є `object` (ось така ось тавтологія).
Чим відрізняється теоретичне поняття об'єкта від object?
Правильною відповіддю буде: нічим. Об'єкт є найбільш, мабуть, із простих
варіантів об'єкту в Kotlin.
Чому? Він має лише одну варіацію (екземпляр) своєї структури.
Що ж, почнемо створювати нашого кота:
```kotlin
object Cat
```
Як можна зазначити, такий тип об'єктів ми записуємо за допомогою ключового слова `object`, 
після якого йде ім'я нашого об'єкта.

#### Властивості
Нумо додамо властивості (змінні) нашому об'єктові:
```kotlin
object Cat {
	val name: String = "Мася"
	val yearsOld: Int = 15 // людських, звичайно
	val weight: Double = 4.5
}
```

**Властивості** - це змінні на рівні об'єкта. Тобто змінні, що
оголошено у його тілі.
Що ж, ми описали нашу улюблену Масю і тепер може брати з об'єкта
інформацію про неї:
```kotlin
fun main() {
	val name = Cat.name
	println(name + " наш улюблений кіт!")
}
```
Воу-воу.. рядок + рядок?
:::info Примітка
Так, таке у програмуванні, називають конкатизацією строк (від англ.
concat - об'єднувати). Логічно буде думати, що вона складає дві строки в
одну з урахуванням їхнього вмісту.
:::

#### Функції
Далі, якщо дивитися на структуру нашого кота, йдуть функції.
Оголошення функцій у класі / поза класом не відрізняється. Все по тій самій
формулі:
```kotlin
object Cat {
	val name: String = "Мася"
	val yearsOld: Int = 15 // людських, звичайно
	val weight: Double = 4.5
	fun meow() {
		println(name + " тільки що нявкнув.")
	}
	fun sleep() {
		println(name + " тільки що задрімав.")
	}
}
```

Зробимо просте друкування того, що котик нявкнув/заснув. Все дуже просто!


Але, що робити, якщо у нас декілька котів? Об'єкт тут вже не варіант.
На допомогу нам приходить, один з видів об'єкта — **Клас**.
Клас може створюватися *в кількох екземплярах*, які будуть незалежними
один від одного.

#### Клас
Давайте ж розглянемо класи лише на рівні мови.
Для початку створимо клас з тією самою назвою:
```kotlin
class Cat {
	val name: String
	val yearsOld: Int
	val weight: Double
	fun meow() {
		println(name + " тільки що нявкнув.")
	}
	fun sleep() {
		println(name + " тільки що задрімав.")
	}
}
```

Оголошення нічим не відрізняється від того, як ми оголошували змінні в тілі
об'єкта або функції.
Але ось проблема! Структура нічого не знає про наших котів!
Ми, звичайно, можемо написати наступне (як це було раніше):
```kotlin
class Cat {
	val name: String = "Мася"
	val yearsOld: Int = 15
	val weight: Double = 4.5
	fun meow() {
		println(name + " тільки що нявкнув.")
	}
	fun sleep() {
		println(name + " тільки що задрімав.")
	}
}
```

Але, у нас кілька котів, як бути?
Завдання вирішується дуже легко логічно - нам потрібно зробити властивості
довільними. Що потрібно для цього зробити? Створити конструктор!

#### Конструктор
Якщо ви знаєте англійську, ви швидше за все, зрозуміли, що конструктор (англ. constructor) щось конструює 
(збирає, створює та інші варіанти перекладу). Використовується для того ж, для чого й аргументи у функцій (насправді,
конструктор - це така ж функція, тільки трохи покращена для своїх
задач) — для передачі якоїсь необхідної інформації нашому коду (структурі)
(наприклад, структура спочатку не знає, як звати нашого кота, ми повинні
задати йому ім'я).

За такою ж формулою, як і з функцією, задаємо параметри класу:
```kotlin
class Cat(name: String, yearsOld: Int, weight: Double) {...}
```

Параметри класу видно лише всередині класу, але не в функціях (пізніше ми поговоримо про області видимості).
Задаймо нашим властивостям довільні значення з конструктора:
```kotlin
class Cat(name: String, yearsOld: Int, weight: Double) {
	val name: String = name
	val yearsOld: Int = yearsOld
	val weight: Double = weight
}
```
Варто зазначити, що подібне повторення назв допускається, оскільки конфлікти
імен неможливі через те, що параметри видно лише всередині тіла класу.
Подібний код явно надто заскладний для такого тривіального завдання! Нам ліньки
стільки писати, як бути?

Котлін розв'язує цю проблему за рахунок того, що допускає оголошення властивостей
в конструкторах!
```kotlin
class Cat(val name: String, val yearsOld: Int, val weight: Double)
```
Вже куди простіше, чи не так?
Варто зазначити, що властивості видно будь-якому місцю, що відноситься
безпосередньо до структури (наприклад, властивості будуть видні при звертанні до екземпляра об'єкта).

Щоб використати даний об'єкт, ми викликаємо його конструктор як будь-яку іншу функцію:
```kotlin
fun main() {
	val cat = Cat("Кіттик", 20, 5.1)
	// ім'я доступне тут
	println(cat.name)	
	// але, не доступно тут:
	println(Cat.name) // потрібен екземпляр класа, що створюється через конструктор
}
```

#### Функції
Функції, знову ж, будуть ідентично записані, як і у звичайного об'єкта:
```kotlin
class Cat(val name: String, val yearsOld: Int, val weight: Double) {
	fun meow() {
		println(name + " тільки що нявкнув.")
	}
	fun sleep() {
		println(name + " тільки що задрімав.")
	}
}
```

Тепер же перейдемо до наших подій.
Нагадаю, що подія - це просто об'єкт, який має деякі функції, що описують наше "повідомлення".
Наприклад, щось таке:
```kotlin
object Event {
	fun whenMeow() {
		println("Він зробив няв!")
	}
	fun whenFellAsleep() {
		println("Поводимося тихо! Він спить.")
	}
}
```

І можемо це викликати з наших функцій, що знаходяться у Коті:
```kotlin
class Cat(val name: String, val yearsOld: Int, val weight: Double) {
	fun meow() {
		Event.whenMeow()
	}
	fun sleep() {
		Event.whenFellAsleep()
	}
}
```

Це і буде варіацією подій.
Але, як ви встигли подумати, такий варіант відтинає можливість мати довільні слухачі. Тобто якщо нам знадобиться для одного окремого кота поміняти "слухач" (наприклад повідомлення всередині) - ми не зможемо.
І на допомогу нам приходить інтерфейс!

### Інтерфейс
**Інтерфейс** (англ. interface) — програмна структура, що визначає відношення між об'єктами, які поділяють певну поведінкову множину і не пов'язані ніяк інакше.

Раніше ми розглядали абстракції стосовно різних вихованців (це ми також розберемо), але поки вирішім більш насущну задачу.

По суті, інтерфейс не має ніякого стану (тобто не може інкапсулюватись: змінювати властивості та ін.). 
Цей тип «об'єктів» лиш описує те, як інші об'єкти будуть поводитись, тобто:
```kotlin
interface Event {
	fun whenMeow()
	fun whenFellAsleep()
}
```
Ми не задаємо якоїсь логіки, а лиш описуємо те, що об'єкт, який наслідує (імплементує) інтерфейс буде робити:
```kotlin
object DefaultEvent : Event { // наслідування відбувається за допомогою символа ':'
	// задавання методів, що були описані в інтерфейсі, відбувається за допомогою ключового слова 'override'
	override fun whenMeow() {
		println("Він зробив няв!")
	}
	// задавання методів, що були описані в інтерфейсі, відбувається за допомогою ключового слова 'override'
	override fun whenFellAsleep() {
		println("Поводимося тихо! Він спить.")
	}
}
```

Що ж щодо нашої задачі, все що нам потрібно тепер, це передати в клас інтерфейс, який можна буде підмінити різними варіаціями за допомогою наслідування.
```kotlin
class Cat(val name: String, val yearsOld: Int, val weight: Double, private val event: Event) { // передали в конструктор інтерфейс
	fun meow() {
		event.whenMeow() // викликали функцію на екземплярі класа, що наслідує Event
	}
	fun sleep() {
		event.whenFellAsleep() // викликали функцію на екземплярі класа, що наслідує Event
	}
}
```

Тепер же, перейдімо до «вихованців», а якщо бути точнішим, до їх різновиду.

> TODO