---
description: Математичні, логічні та умовні оператори в Kotlin
keywords: [kotlin operators, kotlin оператори, туторіал, для новачків, if, when, math]
---
# Оператори
У програмуванні оператором називають символ, що являє собою якусь дію над сутністю (наприклад число, яке ділять на інше число).
Це функція, що має свій спеціальний символ у словнику мови програмування (як, наприклад це з ключовими словами `fun` або `var`).
Давайте за приклад візьмемо теж саме ділення. Щоб зробити ділення, ми можемо використовувати символ `/`.
```kotlin
val result: Int = a / b
```
По-іншому це можна виразити таким чином:
```kotlin
fun divide(a: Int, b: Int): Int {...}
```
Але, для зручності та розуміння, вирішили скорочувати до `/`.
Однак за вами залишається можливість викликати це словесно:
```kotlin
val result = a.div(b) // div - скороченно від divide
```
Тепер, знаючи це, спробуйте вирішити задачу самотужки:
$f(y)=\frac{y}{2}$

Ця задача досить проста:
```kotlin
fun f(y: Int): Int {
	return y / 2
}
```
Не дуже відрізняється від додавання чисел.
Але які ще існують оператори?
## Види операторів
Оператори поділяють такі типи:
- арифметичні - додавання чисел, віднімання, множення, ділення.
  * `+` оператор додавання значень (`a + b`)
  * `-` оператор віднімання значень (`a - b`)
  * `*` оператор множення значень (`a * b`)
  * `/` оператор ділення значень (`a / b`)
  * `%` оператор ділення з залишком (`22 % 4` дорівнюватиме `2`)
  * складені оператори:
    - `+=` оператор додавання до поточної величини ще одне значення.
      Еквівалентно наступному: `a = a + b`.
    - `-=` оператор віднімання значення від поточної величини.
      Еквівалентно наступному: `a = a - b`.
    - `*=` оператор множення поточної величини на деяке значення.
      Еквівалентно наступному: `a = a * b`.
    - `/=` оператор ділення поточної величини на деяке значення.
      Еквівалентно наступному: `a = a / b`.
    - `!=` оператор 'не дорівнює', що відповідає `!(n == 1)` (дужки використовуються для підсумування результатів виразів)
- логічні - порівняння значень:
  - `>` оператор більше ніж (`a > b`)
  * `<` оператор менше ніж (`a < b`)
  * `&&` оператор 'і' (`a > b && b < c`: `a` більше `b` і `b` менше `c`)
  * `||` оператор 'або' (`a > b || c < a`: `a` більше `b` або ж `c` менше `a`)
  * `==` оператор рівності двох значень (`a == 5`)
  * `!` оператор протилежності (якщо у нас `false`, перетворюється на `true` і навпаки)
  * складені оператори:
    * `>=` оператор більше або дорівнює (`a >= 5`)
    * `<=` оператор менше або дорівнює (`a <= 5`)
* та умовні, які працюють з логічними операторами:
  * `if` оператор 'якщо це правда (true), то щось'. Працює в кооперації з `else`: "якщо це правда, то це, але якщо ні, то (фрагмент коду з else)".
  * `when` оператор для кількох 'якщо це правда, то ..'

:::caution Увага
Важливо враховувати, що **порівнювати різні типи 
даних не можна** (але це не стосується цифр).
Тобто, якщо ми порівняємо рядок, наприклад, з цифрою – **ми матимемо помилку при компіляції**.
:::

### Логічні оператори
Розгляньмо логічні оператори, що в мові повертають тип `Boolean`, де є тільки два можливі значення (варіанта): `true` (істина) та `false` (не істина, тобто брехня).

Для уточнення роботи деяких операторів вирішимо кілька дуже простих завдань:

:::info Завдання №1.
Створіть функцію, яка буде говорити чи x більше y.
x, y — цілі числа.
:::
Вирішимо ж, цю нескладну задачу:
```kotlin
/**
 * Ми задаємо функції два параметри типу `Int`.
 * Віддаємо логічний тип `Boolean`, що утворюється завдяки операції порівняня `>`.
 */
fun isBigger(x: Int, y: Int): Boolean = x > y
```

:::info Завдання №2.
Створіть функцію, яка перевірятиме чи не є число нулем.
:::

:::tip Підказка.
Для цього нам знадобиться оператор 'не дорівнює' (`!=`).
:::

```kotlin
fun isNonZero(x: Int): Boolean = x != 0 // все дуже просто
```

:::info Завдання №3.
Створіть функцію, що перевіряє, чи число ділиться націло на 3.
:::

:::tip Підказка.
Щоб вирішити це завдання, нам потрібно буде скористатися оператором залишку 
від ділення (тобто `%`).
:::

Якщо число ділиться націло на інше число, логічно, що залишком від ділення буде нічого, тобто `0`.
Це означає, що нам потрібно скомпонувати два оператори — залишок від ділення та рівності. 
Тобто потрібно зробити наступне `n % 3 == 0` (`n % 3` виконується першим, бо вирази читаються зліва направо).
```kotlin
fun isDivisibleOnThree(x: Int): Boolean {
	return x % 3 == 0
}
```

### Умовні оператори
Давайте більше приділимо увагу умовним операторам.

Для того, щоб зробити програму, що спирається на якісь умови, які потрібно обробити (наприклад, як той випадок, що ми обговорили вище), використовують умовні оператори.
Сама назва говорить нам про те, що ми маємо якусь умову. Давайте ж розберемо якісь види умовних операторів є в Kotlin.
### If else
Одним з умовних операторів є `if-else`.
Дуже проста конструкція, що означає «якщо це істина, то зроби це, якщо ж ні, то це».
Записується так:
```kotlin
...
val isBigger: Boolean = a > b
if(isBigger) {
	println("а більше b!")
} else {
	println("b більше a!")
}
```
Але що ж робити, якщо у нас кілька умов? Наприклад, нам потрібно дізнатися найбільше з трьох довільних.
Використовуючи логіку, можна прийти до того, що в `else {...}` можна дописати ще один `if`. І це буде правильно! Це спрацює.
```kotlin
fun getBiggest(a: Int, b: Int, c: Int) {
	if(a > b && a > c) { // тут, до речі, використовується логічний оператор 'і'
		return a
	} else {
		if(b > a && b > c) {
			return b
		} else {
			return c
		}
	}
}
```
Але, код помітно став набагато складнішим. Може можна спростити?
Так, дійсно, цю конструкцію можна спростити.
Для if, як і для else застосовується одне спрощення:
- Якщо у вас лише один ланцюжок дій, то вказувати фігурні дужки необов'язково.
  Тобто в результаті вийде таке:
```kotlin
if(a > b && a > c)
	return a
else if(b > a && b > c)
	return b
else return c
```
Тепер код став помітно кращим, аніж до цього. Але, друзі, на цьому магія не закінчується:
```kotlin
return if(a > b && a > c) {
	a
} else if(b > a && b > c)
	b
else c
```
Воу-воу, що це таке? Якщо ви раніше вивчали інші мови програмування, ви, можливо, знаєте про «тернарний оператор». Що ж, у Kotlin вирішили зробити можливість використовувати умовний оператор if-else (і забігаючи наперед, так само оператор `when`) як *вираз* (все, що може виражати значення: сире значення типу `10`, функція, що повертає якесь значення та інше, що в результаті повертає нам якесь значення, називають *виразом*).

Що це означає? Це означає, що фрагменти коду в if будуть виступати як умовні функції, які повертають якесь значення (число або щось інше) з кожної обробленої гілки умови. Для того, щоб повернути щось із фрагмента коду, потрібно написати значення (або змінну/функцію, яка матиме потрібне нам значення) останнім у нашому фрагменті коду.

Давайте закріпимо матеріал зробивши наступне:
:::info Завдання
Виконайте наступний вираз на Kotlin:
$$
f(x) =\left\{
\begin{array}{ c l }
x & \quad \textrm{якщо } x \geq 0
\\
2x                 & \quad \textrm{якщо x < 0}
\end{array}
\right.
$$
:::
Тут у нас тільки два значення, що робить задачу дуже примітивною:
```kotlin
fun f(x: Int): Int {
	return if(x >= 0)
		x
	else 2 * x
}
```
Добре, з цим розібралися. Але що робити, якщо у нас буде більше умов? Робити нескінченні ланцюжки `if-else`? Як би не так.
### When
Для великої вибірки умов створили оператор `when`.
Щоб зрозуміти, для яких випадків він використовується, вирішимо таке завдання:
:::info Завдання №1.
Створіть функцію, яка повертатиме день тижня за його порядковим номером.
Тобто: якщо в функцію ввести параметр '1', функція поверне «Понеділок». І так далі.
:::

Для цього, ми можемо використати оператор `when`, який буде куди зрозумілішим нескінченних ланцюжків `if-else`.
```kotlin
fun getDay(ordinal: Int): String {
	return when {
		ordinal == 1 -> "Понеділок"
		ordinal == 2 -> "Вівторок"
		ordinal == 3 -> "Середа"
		ordinal == 4 -> "Четвер"
		ordinal == 5 -> "П'ятниця"
		ordinal == 6 -> "Субота"
		ordinal == 7 -> "Неділя"
		else -> "Вказаний невірний номер"
	}
}
```
Варто відзначити `else`, який також існує в операторі `when`. Працює аналогічно, обробляючи умову, яка не була задоволена доти.
У нашому випадку, якщо ввести в функцію число понад 7, то повернеться повідомлення про те, що вказаний невірний день.
До речі, якось однотипно виглядають умови, чи не так? "Якось дуже багато мороки" - сказав Kotlin, і зробив чергове спрощення:
```kotlin
fun getDay(ordinal: Int): String {
	return when(ordinal) {
		1 -> "Понеділок"
		2 -> "Вівторок"
		3 -> "Середа"
		4 -> "Четвер"
		5 -> "П'ятниця"
		6 -> "Субота"
		7 -> "Неділя"
		else -> "Вказаний невірний номер"
	}
}
```
Як усе зрозуміліше і очевидніше стало, чи не так?
Для закріплення матеріалу вирішимо наступне завдання:

:::info Завдання №2.
Зробіть наступну функцію на Kotlin:
$$
f(x) =\left\{
\begin{array}{ c l }
x + 1 & \quad \textrm{якщо } x < 0
\\
2 x & \quad \textrm{якщо } x \geq 1   
\le 10
\\
x + x & \quad \textrm{якщо } x > 10
\\
0                 & \quad \textrm{інакше}
\end{array}
\right.
$$
:::
У цьому виразі ми маємо цілих 4 умови. Для цього підходить якраз таки наш `when`:
```kotlin
fun f(x: Int): Int {
	return when {
		x < 0 -> x + 1
		x >= 1 <= 10 -> 2 * x
		x > 10 -> x + x
		else -> 0
	}
}
```
:::tip Доповнення
Також ви можете самі оголошувати свої варіанти операторів, 
але про це ми поговоримо якось в інший раз.
:::