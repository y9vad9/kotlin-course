---
id: scope_visibility
---
# Область видимости
Теперь перейдем к достаточно интересной, но немного сложной теме — области видимости.
Ранее мы рассматривали переменные и функции, поэтому теперь следует рассмотреть случаи, когда функция или переменная может быть недоступна или наоборот доступна в некоторых местах.
**Область видимости** (англ. scope) в **программировании** — важная концепция, определяющая доступность переменных, функций и других сущностей. Эта концепция разделяет переменные, функции и т.п. на глобальные и локальные.
Рассмотрим на примере:
```kotlin
fun foo() {
	val a = 1
}
fun main() {
	println(a + 1)
}
```
Данный код вызовет ошибку:
```kotlin
Unresolved reference: a
```
Что означает, что переменная создана в функции `foo()` недоступна в функции `main()`.
Почему? В этом конкретном случае, `a` не может существовать и в теории, потому что она создается при вызове функции `foo`, а она не вызывается.
А если мы ее вызовем?
```kotlin
fun foo() {
	val a = 1
}
fun main() {
	foo()
	println(a + 1)
}
```
Теперь она создана и, по идее, программа должна работать, но как бы не так, мы получим ту же ошибку:
```kotlin
Unresolved reference: a
```
Дело в том, что переменные видны только в месте создания и ниже иерархии.
Ниже иерархии? Перепишем наш код так чтобы наша переменная была доступна:
```kotlin
var a = 0
fun foo() {
	a = 1
}
fun main() {
	foo()
	println(a + 1)
}
```
*(Для наглядности меняем переменную во время вызова `foo()`)*

Подобное и означает «ниже иерархии».
Функция, использующая переменную `a` наследует область видимости (aka scope) файла, в котором ее создали.
И так работает с любым местом, где переменную создают. Даже в функции:
```kotlin
var c = 2
fun foo() {
	var a = 2 // создаем функции на уровне функции.
	c = 4 // переменная, находящаяся вне функции (в файле), доступна
	fun bar() {
		val b = a.pow(2) // переменная `a` доступна в функции `bar` из-за наследования области видимости
		a = b
	}
	bar() // функция доступна в месте ее создания (декларирование)
	println(a) // переменная доступна в месте ее создания
}
```
Да, да, в котлине можно даже создавать функции в функциях, не удивляйтесь! Хотя сейчас не об этом.
В этом случае, функция `bar` наследует область видимости файла, функции `foo` и так может продолжаться до бесконечности. Вообще фигурные скобки `{}` можно рассматривать как оператор, создающий новую область видимости.
Будем визуализировать то, как строится наша область видимости:
![scope](images/scope_visualization_1_ru.excalidraw.svg#invert)

То есть, каждая новая область видимости наследует «отцов», в которых она создается.
Родители (все, что выше иерархии), не видят созданное ниже иерархии.

PS: Вообще переменные, создаваемые в функциях, называют - локальными переменными (функции же, логически, локальными функциями).
А переменная, которую мы создавали вне функции — «глобальная». Она заметна везде, начиная с того же файла, заканчивая другими.
Заканчивая другими? Так же, как мы создавали файл под именем «Main», мы можем создать любой другой файл. Как минимум,
чтобы не держать весь код в одном файле. Это упростит навигацию в проектах немного сложнее тех, которые мы делали раньше.
А что будет, если создать еще один файл, в котором мы создадим некоторые функции и переменные? Что ж, проверим:
```kotlin
// файл: another.kt
val abc = 999_999_999
fun someFunction() {
	println("someFunction()")
}
```
Перейдя в файл «Main» и попытавшись вызвать эти функции, нас ждет успех:
```kotlin
fun foo() {
	val a = 2
	println(a + abc) // получаем переменную из файла `another.kt`
}
```
Что это значит? А это означает то, что файл также, как, например, функция, имеет дочерний scope (область видимости) и это некоторые другие файлы.
Некоторые другие файлы? Не все?

Дело в том, что файлы идентифицируются не только по их названию, но и по их пакету.
Пакет? Логично предположить, что никто не имел в виду полиэтиленовый или какой-нибудь другой пакет, а какой-то уникальный идентификатор.
Что это за уникальный идентификатор и зачем он?
Всё для того же, для чего создаются другие файлы: для удобства. Нужно разделять и сортировать написанный код.
Из реальных примеров вы можете взять системные папки типа Music, Videos, Images и другие, содержащие информацию только определенной категории.
В Котлине подобная система категоризации кода, единственное отличающееся — это термин (**пакет**).
Собственно, как и с системными папками, мы можем делать структуру нашего проекта, разделяя на какие-то осмысленные части.
К примеру, для любых математических вычислений мы можем создать такой пакет:
`math.calculations`.
В файловой структуре мы просто создаем соответствующие части пакета (разделенные точкой).
То есть папку `math`, а в ней еще одну папку `calculations`. После этого можно уже создавать наши файлы с кодом.
Например, создадим файл с функцией, которая будет решать следующее выражение:
$$
f(x) =\left\{
\begin{array}{ c l }
2x^2 & \quad \textrm{если } x < 0
\\
x & \quad \textrm{если } x \geq 1
\le 50
\\
(x \cdot 2)^2 & \quad \textrm{если } x > 50 < 200
\\
1 & \quad \textrm{иначе}
\end{array}
\right.
$$
```kotlin
// файл Function.kt
package math.calculations // автоматически добавилось нашей IDE (идентификатор нашего файла)
fun f(x: Double): Double {
	return when {
		x < 0 -> 2 * x.pow(2)
		x >= 1 <= 50 -> x
		x > 50 < 200 -> (x * 2).pow(2)
		else -> 1
	}
}
```
Как вы уже заметили, сверху у нас добавилась строка кода с местом нашего файла.
Он обязателен, даже если вы поместили его в соответствующую папку. Это потому, что Kotlin допускает указание пакета свободно (т.е. вы можете не создавать файловую структуру, соответствующую пакету).
Это делается в несложных проектах, где 8-10 файлов и проблем с навигацией нет, но я рекомендую вам всегда создавать соответствующую файловую структуру.
Что ж, перейдем к вызову нашей функции:
```kotlin
// файл Main.kt
fun main() {
	println(f(1.0))
}
```
По идее должна работать, но запустив мы получим следующую ошибку:
```kotlin
Unresolved reference: foo
```
Дело в том, что по умолчанию область видимости ограничивается текущим пакетом (в нашем случае хоть он и отсутствует, но он такой же идентификатор, даже если он и пуст).
Чтобы получить что-то из другой области видимости (aka пакета), нужно для начала «импортировать» идентификатор.
"Импорт" производят с помощью ключевого слова `import`. Он всегда должен указываться сверху, сразу после пакета (ну или при его отсутствии, просто сверху).
Схема импорта такова:
```kotlin
import [пакет].[идентификатор]
```
То есть, чтобы вызвать функцию `f(x: Double)`, нам нужно сделать следующее:
```kotlin
// файл Main.kt
import math.calculations.f

fun main() {
	println(f(1.0))
}
```
И у нас все запуститься успешно!
Но если без импортирования идентификаторов других пакетов не видно, можно ли создавать дубликаты названий?
**Да**, вы можете создавать дубликаты имен, за исключением ситуаций, когда вы пытаетесь создать одинаковый идентификатор в одном конкретном скоупе (области видимости).
То есть следующее запрещено:
```kotlin
fun main() {
	val a = 1 // Conflicting declarations: val a: Int, val a: Int
	println(a)
	val a = 2 // Conflicting declarations: val a: Int, val a: Int
	println()
}
```
Но, это возможно:
```kotlin
val a = 1

fun main() {
	println(a)
	val a = 2 // но так не делайте))
	println(a)
}
```
Это все потому, что приоритетным пространством имен (с нашими идентификаторами) есть текущая область видимости (aka скоуп).
Это все потому, что функция (или любое другое место) – это новый независимый скоуп (область видимости).
Мы не можем быть уверены, что рано или поздно мы не импортируем какую-либо переменную или не объявим такую ​​же в этом же файле.
А придумывать новые имена не сделает код проще, а только сделает его более сложным.
Кстати, стоит отметить, что создание дубликатов в одном пакете невозможно.

Для котлина файл не является независимой структурной единицей и существует только в вашей структуре.
Вспомните пример с функцией в пакете `math.calculations`, указываем ли мы конкретный файл при вызове функции или ее импорте? Нет. Поэтому дубликаты в одном пакете и невозможны, поскольку определить конкретный идентификатор файла невозможно.
Что ж, для закрепления визуализируем все то, что мы обсудили выше:
![usage](images/scope_visualization_2_ru.excalidraw.svg#invert)
У нас есть проект с двумя уникальными пакетами: `math.calculations` и родительским (пустым). Файл "Main" завязан на функцию `f(x: Double)` в пакете `math.calculations` (мы выделили это линией для визуализации).
Что ж, подведем промежуточный итог:
- Программа делится на разные области видимости (скоупы), имеющие четкую иерархию в зависимости от того, где и что вы создаете.
- Иерархия обычно такова: область видимости на уровне пакета -> область видимости на уровне декларации (функции, например) -> и т.д. (например, вложенные функции или условные операторы).
- Родительской областью видимости есть пакет, в котором есть наш идентификатор (функция, переменная). Идентификаторы других пакетов не видны по умолчанию.
- При необходимости можно расширить пространство имен (идентификаторы, которые видны в другой области видимости) с помощью импорта (`import [пакет].[идентификатор]`).
## Модификаторы видимости
Кстати, говоря о том, что файл – это не независимая структура, я немного соврал и сейчас объясню почему.
Давайте решим следующий пример:
$$
f(x) =\left\{
\begin{array}{ c l }
x^2 & \quad \textrm{если } x < 0
\\
a(x) & \quad \textrm{иначе}
\end{array}
\right.
$$
Функция $a(x)$ у нас такова:
$$
a(x) =\left\{
\begin{array}{ c l }
2x & \quad \textrm{если } x > 0 < 200
\\
1 & \quad \textrm{иначе}
\end{array}
\right.
$$
На Kotlin нам нужно написать следующее (в файле math.calculations.Function):
```kotlin
fun f(x: Double): Double {
	return if(x < 0) x.pow(2) else a(x)
}
fun a(x: Double): Double {
	return if(x > 0 < 200) 2 * x else 1
}
```
Теперь же, вызовем функцию `f(x)`
```kotlin
fun main() {
	val input = 2.0 // любое число
	println(f(input))
}
```
И на этом наша программа, условно, окончена.
Посмотрев на функцию `a(x: Double)` мы можем подумать о том, что она используется только в функции `f(x: Double)`
и в принципе она нигде кроме как в файле 'Function.kt' не требуется.
Можно ли эту функцию просто игнорировать в подсказках и не импортировать, однако, если таких функций много?
Или нам нужно спрятать что-то ради чего-нибудь другого.
Это очевидно, загромождает глобальное пространство имен, даже если оно не импортировано.
На помощь нам приходят модификаторы видимости! **Модификаторы видимости** — ключевые слова, описывающие то, где виден идентификатор.
Для нашего случая существует модификатор `private`. Он показывает, что функция видна только там, где ее создали и ниже иерархии.
На самом деле формула создания той же функции выглядит следующим образом:
```kotlin
[модификатор-видимости] fun [названиеФункции](параметр: Тип): Тип {...}
```
По умолчанию ко всем декларациям (функциям, переменным и прочему) неявно применяется модификатор `public` (т.е. публичный, видимый наружу).
`fun main()` -> `public fun main()`.
В нашем случае, мы делаем следующее:
```kotlin
private fun a(x: Double): Double {
	return if(x > 0 < 200) 2 * x else 1
}
```
Кстати, указание одинаковых частных идентификаторов в одном пакете, но в разных файлах допускается, поскольку конфликт просто невозможен.

С переменной будет так же:
```kotlin
private val a: Int = 0
```
## Заключение
Первоначальное рассмотрение уникальности имен, создание переменных и функций оказалось не столь простым, как вы уже поняли.
Как я уже упоминал ранее, идентификатор функции строится на следующих его свойствах – имя и параметры.
С учетом рассматриваемых тем: *область видимости* и *модификаторов видимости*, мы их добавляем в уникальность идентификатора (обычно это называют сигнатурой).
Да и то же мы делаем с переменной.
Итоговым вариантом идентификаторов у нас будут:
- Функция – модификатор видимости + область видимости + имя + набор параметров (различие в количестве или типе).
- Сменная – модификатор видимости + область видимости + имя.

Желательно самому поиграть с этим для большего понимания!
