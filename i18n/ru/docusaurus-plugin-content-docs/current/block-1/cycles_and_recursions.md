---
id: cycles
---
# Циклы и Рекурсии
Теперь же, перейдем к довольно интересной, но опять же немного непростой теме — циклы.
Чтобы больше понять, что такое циклы, создадим какую-нибудь задачу. Например, возьмем задачу, которую мы решали в прошлой теме.
Чтобы решить уравнения с использованием ввода, мы каждый раз запускаем нашу программу.
А что если сделать в нашей программе бесконечный ввод, чтобы каждый раз не перезапускать нашу программу?

Вообще без нашей темы циклов это вполне можно было решить следующим образом:
```kotlin
fun main() {
	println("Введите число:")
	val input: Double = readln().toDouble()
	println("Результат: " + input.toString())
	return main() // в конце функции просто вызываем ее еще раз
}
```
И вот, решение найдено!

Подобное называют рекурсией. Простыми словами – это понятие объявления (надписи, описания) кода функции через саму себя.
Это как матрешка, которая в нашем случае не имеет конца.

Что ж, а как сейчас завершить нашу программу? Можно, конечно, это сделать, закрыв принудительно процесс программы через
инструменты системы или IDE, но давайте будем людьми и сделаем какой-нибудь механизм выхода.

Чтобы сильно не возиться, введем условие, что для выхода из программы нам нужно написать «:q».
```kotlin
fun main() {
	println("Введите число: (или воспользуйтесь :q для выхода):")
	val input: String = readln() // создаем переменную с текстом, потому что нам нужно проверять ввод пользователя
	if(input != ":q") {
		val input: Double = input.toDouble() // сила областей видимости!
		println("Результат: " + f(input).toString())
		main()
	}
}
```

Это так же останется рекурсией, только уже не нескончаемой (у нас появилось условие).

Что ж, рассмотрев достаточно простой пример рекурсии, к которому можно было прийти самому при попытке решить задачу
с перезапуском решения уравнений.

Что такое циклы?
:::info Определение
**Циклы** - это средства речи, воспроизводящие рекурсию.
Их также относят к операторам, называя *циклическими* операторами.
:::

Теперь рассмотрим, как это можно решить другими средствами языка. Не всегда же вы будете создавать отдельно функции для
'повторение чего-то', да?

## While
Для облегчения вам жизни придумали достаточно полезную конструкцию – `while`.
Записывается так:
```kotlin
while(boolean) {
	// здесь повторяющееся действие
}
```

Подобная конструкция выполняет свое содержимое в `{}`, но перед каждым исполнением смотрит в условие (aka boolean-выражение)
и если там `true`, то содержание выполняется, а если `false` – нет.

Наш предыдущий код можно выразить через `while` следующим образом:
```kotlin
fun main() {
	var shouldRun: Boolean = true
	while(shouldRun) {
		println("Введите число (или воспользуйтесь :q для выхода):")
		val input: String = readln()
		if(input ==":q") {
			shouldRun = false // при следующем исполнении цикл увидит, что условие `false`
		} else {
			val input: Double = input.toDouble()
			println("Результат: " + f(input).toString())
		}
	}
}
```
Вот и наш первый цикл! Но какой-то он сложен, вам не кажется?
Все это можно упростить воспользовавшись специальными дополнительными операторами: `break` и `continue`.

Что делают эти два оператора? Разберемся.
- `break` (можно перевести как разорвать, оборвать) – принудительно заканчивает цикл.
То есть даже если условие будет `true` цикл все равно закончится.
- `continue` (переводится как продолжить) – заканчивает выполнение текущего *повторения*.
В отличие от `break`, `continue`, грубо говоря, выходит из кода (код после него не выполняется) и переходит сразу к следующему повторению (до проверки условия и последующему повторению в случае, если там `true`).

Давайте перепишем наш код:
```kotlin
fun main() {
	while(true) { // условие нам не нужно
		println("Введите число (или воспользуйтесь :q для выхода):")
		val input: String = readln()
		if(input ==":q") {
			break // выходим из цикло
		} else {
			val input: Double = input.toDouble()
			println("Результат: " + f(input).toString())
			continue // вообще, он необязателен в нашем случае, но для наглядности добавим
			println("Я не напечатаюсь!") // IDE нам подскажет, что до этого участка кода мы никогда не дойдем через continue
		}
	}
}
```

Из-за ненадобности мы выбросили переменную `shouldRun`, потому что есть куда более удобный способ из `break`.
### Do-while
Одним из подвидов цикла while является `do-while`. Кроме названия, он отличается тем, что в **do while** сначала
выполняется тело цикла, а затем проверяется условие продолжения цикла. Из-за такой особенности **do while** называют
циклом с *постумовою*, а обычный **while** называют циклом с *предпосылкой*.

Записывается так:
```kotlin
do {
	// что-то
} while(bool)
```

В таком цикле также существует 'break' и 'continue', которые никак не отличаются.
Однако нашу задачу можно решить через **do-while** и без них:
```kotlin
// создадим переменную с сообщением, чтобы потом ее переиспользовать
val numberInputMessage = "Введите число (или :q для выхода):"

// создадим отдельную функцию для удобства
private fun requestInput(message: String): String {
	println(message)
	return readln()
}

fun main() {
	var input = requestInput(numberInputMessage)
	do {
		println("Результат: " + f(input.toDouble()).toString())
		input = requestInput(numberInputMessage) // записываем следующий ввод, чтобы проверить после введенного повторения.
	} while(input != ":q") // если ввод не ":q" программа будет продолжать работать
}
```
Мы создали для удобства функцию и переменную, сочетавшую похожий код. Снова сделали переменную вне цикла и запись
ее в конце цикла (для того чтобы проверять после повторения ввода пользователя).

Это альтернативное решение, хоть и не самое лучшее.
## For
И теперь перейдем к не менее важному виду циклов – `for`.
Отличие этого вида циклов состоит в том, что он строится не при условии, а на итераторе.
Что такое итератор? Итератор – это встроенная утилита в язык, проходящая между какой-то суммой элементов.
То есть каждое *повторение* будет соответствовать одному элементу в этой сумме.
В нашем случае, эта сумма элементов будет соответствовать диапазону, а элемент единицы счета этого диапазона.

Что такое диапазон? Простыми словами – интервал значений любой величины.
Примером диапазона может служить \[0; 5\] (описывает интервал чисел от 0 до 5, включительно).
Бывают разные виды диапазонов, но пока мы рассмотрим самый простой вариант с диапазоном целых чисел.

Как сделать таковой цикл? Для начала рассмотрим прогрессию с целыми числами:
```kotlin
for(i in 0..5) {
	println(i)
}
```

Здесь мы видим оператор `in`, работающий с итератором (в нашем случае, с тем, что его выражает – диапазоном).

Этот код напечатает следующее:
```
0
1
2
3
4
5
```
Достаточно очевидно работает, не правда ли?

Решим следующее задание:
:::info Задание
Воспроизведите функцию степени для положительных чисел.
Эквивалентны функции `Int.pow(x: Double)`.
:::
```kotlin
fun pow(number: Int, times: Int): Int {
	var output = number // создаем переменную, где сохраняется умноженное значение
	for(i in 1..times) { // через диапазон указываем, сколько раз цикл должен повториться
		output *= number // умножаем то, что уже есть, на параметр number
	}
	return output // возвращаем число в степени
}
```
Здесь нам IDE подскажет, что идентификатор не используется и его лучше заменить на `_`.
Дело в том, что в котлине по код-стилю принято, что неиспользуемые идентификаторы называют именно так.

Что касается задачи, здесь несложный императивный вариант решения.

Решим еще одну задачу:
:::info Задание
Напишите приложение, где пользователь вводит **любое целое положительное число.**
А программа подытоживает все числа от 1 до введенного пользователем числа.
То есть, если введут число 4, мы должны суммировать следующие числа: 1+2+3+4.
:::

В этом нам очень помогут диапазоны!
```kotlin
fun sum(input: Int): Int {
	var output: Int = 0 // создаем временную переменную, которая будет сохранять изменяющееся в цикле значение

	for(i in 1..input)
		output += i // можно убрать `{}`, ибо здесь одна последовательность действий

	return output
}
```
Мы создали временную переменную и снова использовали диапазоны с переменной `i`,
содержащий элемент интервала этого диапазона на каждую итерацию (повторение) цикла
(который и отвечает тому, что мы по существу и делаем).

И напоследок, решим еще одну задачу:
:::info Задание
Данные натуральные числа от 1 до 50. Найти сумму из них, которые делятся на 5 или 7.
:::

:::tip Вспомните
Перед решением этой задачи, упомянем один из арифметических операторов – `%` (остаток от деления).
```kotlin
fun main() {
	println(22 % 4)
	println(4 % 2)
}
```
Напечатает `2` и `0`, поскольку будет такой остаток после разделения (в первом не делится нацело, во втором – делится).
:::
Наша задача состоит в том, чтобы найти числа, делящиеся нацело на 5 и 7.
Это будет эквивалентно следующему:
```kotlin
number % 5 == 0 || number % 7 == 0
```
Это условие будет нам подходить. Теперь же остается только сделать цикл и временную переменную, в которую мы будем добавлять результат.
```kotlin
fun main() {
	var temp: Int = 0
	for(i in 1..50)
	if(i % 5 == 0 || i % 7 == 0)
		temp += i
	println("Сумма: " + temp)
}
```

Ответом у нас должно получиться: `436`.