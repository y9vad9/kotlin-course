---
id: random_numbers
---
# Случайность в Kotlin
Я думаю, вы много раз встречались с понятием «случайности».
Была ли это лотерея, или энеки-бенеки – неважно.
Наша жизнь постоянно постигнет та или иная случайность. Рассмотрим, как случайность работает в Kotlin.

## Random
Говоря о случайности в Kotlin, любой Kotlin-разработчик сразу вспомнит `kotlin.random`
пакет, встроенный в Kotlin.

С помощью него вы можете:
- генерировать случайные числа: цели (`Int`, `Long`) и с плавающей точкой (`Float`, `Double`)
- генерировать случайный логический тип 'Boolean'

:::tip Не мешает знать
Также `kotlin.random` может генерировать байты и биты, но мы эти типы еще не рассматривались.
:::

Перейдем к более практичной части. **Как это все делается?**

Чтобы получить случайное целое число, мы можем использовать функцию `Random.nextInt(from, until)`:
```kotlin title="Main.kt"
import kotlin.random.Random

fun main() {
    println(Random.nextInt(0, 9))
}
```
Выведет:
```text title="Console"
8
```
То есть случайность ограничена от 0 до 9.
:::caution Внимание
Могут быть любые цифры, главное – не перепутать
'от' из 'до' и не сделать следующее `Random.nextInt(9, 0)`. Будет ошибка!
:::
По аналогии работают и другие функции:
```kotlin title="Main.kt"
import kotlin.random.Random

 fun main() {
    println(Random.nextInt(0, 9))
     // highlight-next-line
    println(Random.nextLong(1L, 1000000L))
     // highlight-next-line
    println(Random.nextDouble(1.9, 9.9))
     // highlight-next-line
    println(Random.nextBoolean())
}
```
Выведет примерно следующее:
```text title="Console"
2
386039
7.176104912683028
false
```
Решим следующее задание:
:::info Задание №1
Пользователь вводит число от 1 до 30 (проверьте число). Сделайте программу, которая будет
угадывать число пользователя и печатать сколько попыток потребовалось, чтобы угадать указанное число.
:::
Сначала получим число и проверим его:
```kotlin {2-6}
fun main() {
    val number = readln().toInt()
    if(number < 0 || number > 30) {
        println("Число должно быть в диапазоне между 1 и 30.")
        return // исходим из функции
    }
}
```
Теперь для того, чтобы угадать число, мы можем воспользоваться циклическим оператором `while`

```kotlin {1,10-16}
import kotlin.random.Random // добавляем в наше пространство имен тип Random

fun main() {
    val number = readln().toInt()
    if (number < 0 || number > 30) {
        println("Число должно быть в диапазоне между 1 и 30.")
        return // исходим из функции
    }

    var attempt = 0 // делаем переменную, чтобы сохранять количество попыток
    while (true) {
        if (Random.nextInt(0, 30)) {
            println("Число было найдено за $number") // производим конкатенацию
            break // выходим из цикла
        }
        attempt++ // добавляем 1 к attempt
    }
}
```
:::tip Интересно знать
Какое-то непонятное `attempt++`, не правда ли? На самом деле это просто упрощение для
`attempt=attempt+1`. Оно также существует и в другую сторону: `attempt--`.

Кстати, такая операция имеет два вида:
- префиксный инкеремент/декремент
- постфиксный инкремент/декремент

В нашем случае это постфиксный инкремент. Но чем они отличаются?

Префиксный инкремент сначала добавляет, а затем возвращает значение из выражения, а постфиксный
инкремент сначала отдает значение, а затем добавляет один. Есть:
```kotlin
var x = 0
println(x++) // выведет 0
println(x) // только здесь он выведет 1

var y = 0
println(++y) // выведет 1
```
:::
И мы решили эту несложную задачу.

[//]: # (## SecureRandom)

[//]: # (Мы поговорили об обычном Random, теперь же поговорим о более безопасной случайности.)

[//]: # (Почему обычная случайность не безопасна? Чтобы не вдаваться в математику, скажу просто –)

[//]: # (алгоритм получения является «предсказуемым». То есть, зная, как работает алгоритм, вы можете)

[//]: # (предположить следующее число.)

[//]: # ()
[//]: # (И здесь нам на помощь приходит «безопасный» вариант случайности.)

[//]: # (Почему эта случайность безопасна, а предыдущая нет? Все просто: SecureRandom )

[//]: # (использует случайные данные из операционной системы. Какие именно? Например, может брать)

[//]: # (данные поведения пользователя &#40;движение мыши и др.&#41;, которые всегда уникальны. )

[//]: # (Также SecureRandom использует более надежный алгоритм генерации случайных чисел.)

[//]: # ()
[//]: # (:::tip Узнать больше)

[//]: # (Если заинтересованы в этой теме, можете прочитать)

[//]: # ([этот ответ]&#40;https://stackoverflow.com/a/11052736/11849017&#41; на stackoverflow.)

[//]: # (:::)

[//]: # (По названиям функции не отличаются, но по параметрам – да.)

[//]: # (Но, мы можем воспользоваться функцией `asKotlinRandom&#40;&#41;`, )

[//]: # (чтобы иметь такие же функции, как и у предыдущего Random.)

[//]: # ()
[//]: # (````kotlin title="Main.kt")

[//]: # (import java.security.SecureRandom // SecureRandom не является частью Kotlin, но находится на платформе Java.)

[//]: # (import kotlin.random.Random)

[//]: # (import kotlin.random.asKotlinRandom)

[//]: # ()
[//]: # (fun main&#40;&#41; {)

[//]: # ( val random: Random = SecureRandom&#40;&#41;.asKotlinRandom&#40;&#41;)

[//]: # ( println&#40;random.nextInt&#40;1, 9&#41;&#41;)

[//]: # (})

[//]: # (```)

[//]: # (:::info Информация)

[//]: # (Как вы уже видите, мы получаем SecureRandom с помощью функции `SecureRandom&#40;&#41;`)

[//]: # (&#40;на самом деле, это не совсем так, но пока так оставим&#41;, которая возвращает нам тип данных от имени которого)

[//]: # (мы уже можем делать операции.)

[//]: # (:::)


